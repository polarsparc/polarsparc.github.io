<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="content-type" content="application/xhtml+xml; charset=windows-1252" />
    <meta name="author" content="Bhaskar.S">
    <meta name="description" content="Introduction to Terraform">
    <meta name="subject" content="Introduction to Terraform">
    <meta name="keywords" content="minikube, terraform">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <title>Introduction to Terraform</title>
    <link href="../css/polarsparc-v2.4.css" type="text/css" rel="stylesheet" />
  </head>
  <body>
    <br/>
    <table borber="0">
      <tr>
        <td valign="bottom"><span id="gen-home"></span></td>
        <td valign="bottom"><span id="gen-home-a"><a id="gen-home-a" href="https://polarsparc.github.io/">PolarSPARC</a></span></td>
      </tr>
    </table>
    <br/>
    <div id="gen-title-div">
      <p>Introduction to Terraform</p>
    </div>
    <br />
    <table id="gen-ad-table">
      <tbody>
        <tr>
          <td class="author-td">Bhaskar S</td>
          <td class="date-td">03/12/2023</td>
        </tr>
      </tbody>
    </table>
    <hr class="gen-line-hr"/>
    <br/>
    <div id="gen-step-div">
      <p>Overview</p>
    </div>
    <br/>
    <div id="para-div">
      <p><a href="https://www.terraform.io/" target="_blank"><span class="hi-yellow">Terraform</span></a> is an open source
        <span class="bold">Infrastructure as Code</span> deployment tool which enables system administrators to provision and manage
        the Enterprise infrastructure (public cloud or on-prem) in a consistent and predictable manner.</p>
      <p>The idea behind <span class="bold">Terraform</span> is that system adminstrators can describe the Enterprise infrastructure
        configuration in the form of a human readable text, which can be version controlled and maintained just like code.</p>
      <p><span class="bold">Terraform</span> integrates with the various infrastructure services via the <span class="hi-yellow">
        Providers</span>. Think of them as extensions (or plugins) to the core <span class="bold">Terraform</span> platform.</p>
      <p><span class="bold">Providers</span> are developed and distributed by partners and vendors via the
        <a href="https://registry.terraform.io/" target="_blank"><span class="hi-yellow">Terraform Registry</span></a>.</p>
      <p>The <span class="bold">Terraform</span> infrastructure configuration code is stored in text files with the extension
        <span class="hi-blue">.tf</span>.</p>
    </div>
    <br/>
    <div id="gen-step-div">
      <p>Basics</p>
    </div>
    <br/>
    <div id="para-div">
      <p>In the following section, we will describe the commonly used elements of a <span class="bold">Terraform</span> configuration
        file for one to get started quickly.</p>
    </div>
    <div id="para-div">
      <p>The following is the generic template for a <span class="bold">Terraform</span> configuration file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">generic.tf</div>
      <div class="gen-src-body">
<pre>variable "variable-name" {
  type = variable-type
  description = "some meaningful description of the variable"
  default = default-value
  sensitive = false | true
}

provider "provider-name" {
  provider-arguments
}

resource "resource-type-1" "resource-name-1" {
  resource-arguments-1
}

resource "resource-type-2" "resource-name-2" {
  resource-arguments-2
}

resource "resource-type-3" "resource-name-3" {
  resource-arguments-3
  depends_on = [resource-type-1.resource-name-1, resource-type-2.resource-name-2]
}

output "output-name" {
  value = output-value
  description = "some meaningful description of the output"
  sensitive = false | true
}
</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>The following are the definitions for the various <span class="bold">Terraform</span> elements from the above template:</p>
    </div>
    <div id="para-div">
      <ul id="gen-sqr-ul">
        <li><p><span class="hi-yellow">variable</span> :: refers to an user supplied input value, which can be referenced in the
          <span class="bold">Terraform</span> configuration file as <span class="hi-blue">var.variable-name</span>. There can be
          more than one input variable defined in the configuration file</p></li>
        <li><p><span class="hi-yellow">variable-type</span> :: can be a primitive type such as <span class="hi-blue">string</span>,
          <span class="hi-blue">number</span>, or <span class="hi-blue">bool</span> OR a collection type like <span class="hi-blue">
          list</span> or <span class="hi-blue">map</span></p></li>
        <li><p><span class="hi-yellow">description</span> :: a string that provides useful information to the user</p></li>
        <li><p><span class="hi-yellow">default-value</span> :: indicates the default value to use in case the value is not supplied
          by the user</p></li>
        <li><p><span class="hi-yellow">sensitive</span> :: if set to true, the value of the variable will <span class="underbold">
          NOT</span> appear in either the logs or the terminal</p></li>
        <li><p><span class="hi-yellow">provider</span> :: indicates the provider plugin that will be used in the configuration file.
          As indicated earlier, the provider is the binary extension offered by the respective service owner. For example, for any
          of the resources to be provisioned in the Amazon cloud, use the <span class="hi-blue">aws</span> provider. For any of the
          resources to be provisioned in the Microsoft cloud, use the <span class="hi-blue">azurerm</span> provider, and so on.</p>
          <p>There can be multiple providers referenced in the configuration file</p></li>
        <li><p><span class="hi-yellow">provider-arguments</span> :: defines the various parameters that are needed to initialize
          and configure the specific provider</p></li>
        <li><p><span class="hi-yellow">resource</span> :: indicates the specific resource on the provider that needs to be created
          or modified</p></li>
        <li><p><span class="hi-yellow">resource-arguments</span> :: defines the various parameters that are needed to initialize
          and configure the specific resource on the specific provider</p></li>
        <li><p><span class="hi-yellow">depends_on</span> :: indicates the specific resource on which it is defined depends on the
          list of specific resources on the specific provider, meaning they need to be setup before this</p></li>
        <li><p><span class="hi-yellow">output</span> :: displays the specified value in the logs or the terminal for the user</p></li>
      </ul>
    </div>
    <br/>
    <div id="gen-step-div">
      <p>Installation and Setup</p>
    </div>
    <br/>
    <div id="para-div">
      <p>We will perform the installation and setup on a <span class="hi-yellow">VirtualBox</span> VM running Ubuntu 22.04 LTS.</p>
      <p>Also, the logged in username will be <span class="hi-yellow">alice</span>.</p>
    </div>
    <div id="para-div">
      <p>Open a <span class="bold">Terminal</span> window to perform the various steps.</p>
    </div>
    <div id="para-div">
      <p>To perform a system update and install the prerequisite software, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ sudo apt update && sudo apt install apt-transport-https ca-certificates curl software-properties-common -y</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical trimmed output:</p>
    </div>
    <div id="out-div">
      <h4>Output.1</h4>
      <pre>...[ SNIP ]...
ca-certificates is already the newest version (20211016ubuntu0.22.04.1).
ca-certificates set to manually installed.
The following additional packages will be installed:
  python3-software-properties software-properties-gtk
The following NEW packages will be installed:
  apt-transport-https curl
The following packages will be upgraded:
  python3-software-properties software-properties-common software-properties-gtk
3 upgraded, 2 newly installed, 0 to remove and 14 not upgraded.
...[ SNIP ]...</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To add the <span class="bold">Docker</span> package repository, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</p>
      <p>$ echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.2</h4>
      <pre>deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu jammy stable</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To install <span class="bold">docker</span>, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ sudo apt update && sudo apt install docker-ce -y</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical trimmed output:</p>
    </div>
    <div id="out-div">
      <h4>Output.3</h4>
      <pre>...[ SNIP ]...
Get:5 https://download.docker.com/linux/ubuntu jammy InRelease [48.9 kB]  
Get:6 https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages [13.6 kB]
...[ SNIP ]...</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To add the logged in user <span class="bold">alice</span> to the group <span class="bold">docker</span>, execute the following
        command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ sudo usermod -aG docker ${USER}</p>
    </div>
    <div id="para-div">
      <p><span class="underbold">Reboot</span> the Ubuntu 22.04 LTS VM for the changes to take effect.</p>
    </div>
    <div id="para-div">
      <p>To verify <span class="bold">docker</span> installation was ok, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ docker info</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.4</h4>
      <pre>Client:
  Context:    default
  Debug Mode: false
  Plugins:
    buildx: Docker Buildx (Docker Inc.)
      Version:  v0.10.2
      Path:     /usr/libexec/docker/cli-plugins/docker-buildx
    compose: Docker Compose (Docker Inc.)
      Version:  v2.16.0
      Path:     /usr/libexec/docker/cli-plugins/docker-compose
    scan: Docker Scan (Docker Inc.)
      Version:  v0.23.0
      Path:     /usr/libexec/docker/cli-plugins/docker-scan

Server:
  Containers: 0
    Running: 0
    Paused: 0
    Stopped: 0
  Images: 0
  Server Version: 23.0.1
  Storage Driver: overlay2
    Backing Filesystem: extfs
    Supports d_type: true
    Using metacopy: false
    Native Overlay Diff: true
    userxattr: false
  Logging Driver: json-file
  Cgroup Driver: systemd
  Cgroup Version: 2
  Plugins:
    Volume: local
    Network: bridge host ipvlan macvlan null overlay
    Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
  Swarm: inactive
  Runtimes: runc io.containerd.runc.v2
  Default Runtime: runc
  Init Binary: docker-init
  containerd version: 2456e983eb9e37e47538f59ea18f2043c9a73640
  runc version: v1.1.4-0-g5fd4c4d
  init version: de40ad0
  Security Options:
    apparmor
    seccomp
    Profile: builtin
    cgroupns
  Kernel Version: 5.19.0-32-generic
  Operating System: Ubuntu 22.04.2 LTS
  OSType: linux
  Architecture: x86_64
  CPUs: 2
  Total Memory: 3.832GiB
  Name: xubuntu-vm-1
  ID: 859dad55-839f-4a1a-90de-9212fab79df8
  Docker Root Dir: /var/lib/docker
  Debug Mode: false
  Registry: https://index.docker.io/v1/
  Experimental: false
  Insecure Registries:
    127.0.0.0/8
  Live Restore Enabled: false</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>For the hands-on demonstration, we will setup a single node development cluster using the lightweight implementation of
        <span class="bold">Kubernetes</span> called the <span class="hi-yellow">Minikube</span>.</p>
    </div>
    <div id="para-div">
      <p>To download and install the <span class="hi-blue">minikube</span> binary, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ cd $HOME/Downloads</p>
      <p>$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</p>
      <p>$ sudo install -o root -g root -m 0755 minikube-linux-amd64 /usr/local/bin/minikube</p>
      <p>$ rm -f minikube*</p>
    </div>
    <div id="para-div">
      <p>To verify the version of the <span class="bold">minikue</span> binary, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ minikube version</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.5</h4>
      <pre>minikube version: v1.29.0
commit: ddac20b4b34a9c8c857fc602203b6ba2679794d3</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To start a single node <span class="bold">minikube</span> cluster on the VM, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ minikube start</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.6</h4>
      <pre>minikube v1.29.0 on Ubuntu 22.04
Automatically selected the docker driver
Using Docker driver with root privileges
Starting control plane node minikube in cluster minikube
Pulling base image ...
Downloading Kubernetes v1.26.1 preload ...
&gt; gcr.io/k8s-minikube/kicbase...:  407.19 MiB / 407.19 MiB  100.00% 52.15 M
&gt; preloaded-images-k8s-v18-v1...:  397.05 MiB / 397.05 MiB  100.00% 6.52 Mi
Creating docker container (CPUs=2, Memory=2200MB) ...
Preparing Kubernetes v1.26.1 on Docker 20.10.23 ...
* Generating certificates and keys ...
* Booting up control plane ...
* Configuring RBAC rules ...
Configuring bridge CNI (Container Networking Interface) ...
* Using image gcr.io/k8s-minikube/storage-provisioner:v5
Verifying Kubernetes components...
Enabled addons: default-storageclass, storage-provisioner
Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To verify the status of the <span class="bold">minikube</span> cluster, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ minikube status</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.7</h4>
      <pre>minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>We need to create a storage mount point in <span class="bold">minikube</span>. To do that, login to the <span class="bold">
        minikube</span> single node cluster by executing the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ minikube ssh</p>
    </div>
    <div id="para-div">
      <p>The shell prompt will change to indicate we are in <span class="bold">minikube</span> environment and the following would
        be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.8</h4>
      <pre>Last login: Thu Mar 11 20:37:43 2023 from 192.168.49.1
docker@minikube:~$</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Execute the following commands in the <span class="bold">minikube</span> environment to create mount point loacted in the
        root directory <span class="hi-blue">/pv-storage</span> and then exit:</p>
    </div>
    <div id="gen-cmd-div">
      <p>docker@minikube:~$ sudo mkdir -p /pv-storage</p>
      <p>docker@minikube:~$ exit</p>
    </div>
    <div id="para-div">
      <p>On the host VM, we will create a shared persistent directory called <span class="hi-blue">$HOME/Downloads/pv-storage</span>
        that will be attached to the <span class="bold">Kubernetes</span> cluster (single node cluster) at the mount point directory
        called <span class="hi-blue">/pv-storage</span>.</p>
    </div>
    <div id="para-div">
      <p>To create the shared persistent directory on the host VM, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ mkdir -p $HOME/Downloads/pv-storage</p>
    </div>
    <div id="para-div">
      <p>Open a new <span class="bold">Terminal</span> window on the host VM and execute the following command to mount the shared
        persistent directory on the <span class="bold">minikube</span> cluster:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ minikube mount $HOME/Downloads/pv-storage:/pv-storage</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.9</h4>
      <pre>Mounting host path /home/alice/Downloads/pv-storage into VM as /pv-storage ...
  * Mount type:   
  * User ID:      docker
  * Group ID:     docker
  * Version:      9p2000.L
  * Message Size: 262144
  * Options:      map[]
  * Bind Address: 192.168.49.1:34935
  Userspace file server: ufs starting
  Successfully mounted /home/alice/Downloads/pv-storage to /pv-storage

  NOTE: This process must stay alive for the mount to be accessible ...</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To download and install the <span class="hi-blue">kubectl</span> binary, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ cd $HOME/Downloads</p>
      <p>$ curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"</p>
      <p>$ sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</p>
      <p>$ rm -f kubectl*</p>
    </div>
    <div id="para-div">
      <p>To verify the version of the <span class="bold">kubectl</span> binary, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ kubectl version --output=yaml</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.10</h4>
      <pre>clientVersion:
  buildDate: "2023-02-22T13:39:03Z"
  compiler: gc
  gitCommit: fc04e732bb3e7198d2fa44efa5457c7c6f8c0f5b
  gitTreeState: clean
  gitVersion: v1.26.2
  goVersion: go1.19.6
  major: "1"
  minor: "26"
  platform: linux/amd64
kustomizeVersion: v4.5.7
serverVersion:
  buildDate: "2023-01-18T15:51:25Z"
  compiler: gc
  gitCommit: 8f94681cd294aa8cfd3407b8191f6c70214973a4
  gitTreeState: clean
  gitVersion: v1.26.1
  goVersion: go1.19.5
  major: "1"
  minor: "26"
  platform: linux/amd64</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Now, to download and install the <span class="hi-blue">terraform</span> binary, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ cd $HOME/Downloads</p>
      <p>$ wget https://releases.hashicorp.com/terraform/1.4.0/terraform_1.4.0_linux_amd64.zip && unzip terraform_1.4.0_linux_amd64.zip</p>
      <p>$ sudo install -o root -g root -m 0755 terraform /usr/local/bin/terraform</p>
      <p>$ rm -f terraform*</p>
    </div>
    <div id="para-div">
      <p>To verify the version of the <span class="bold">terraform</span> binary, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform version</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.11</h4>
      <pre>Terraform v1.4.0
on linux_amd64</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Finally, we will create a directory on the host VM, which will act as the root for the <span class="bold">Terraform</span>
        demonstration. To do that, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ mkdir -p $HOME/Downloads/TF</p>
      <p>$ cd $HOME/Downloads/TF</p>
    </div>
    <div id="para-div">
      <p><span class="bold">WALLA !!!</span> - with this we have completed the necessary setup for the demonstration.</p>
    </div>
    <br/>
    <div id="gen-step-div">
      <p>Hands-on Terraform</p>
    </div>
    <br/>
    <div id="para-div">
      <p>In the article <a href="https://www.polarsparc.com/xhtml/K8S-Storage.html" target="_blank"><span class="bold">Hands-on
        Kubernetes Storage</span></a>, we demonstrated how one can create a local persistent storage on the host and use it in the
        <span class="bold">Kubernetes</span> environment. We will replicate the same <span class="bold">Local Storage</span> case
        using <span class="bold">Terraform</span>.</p>
    </div>
    <div id="para-div">
      <p>For the demonstration, we will make use of two providers - <span class="hi-blue">null</span> and <span class="hi-blue">
        kubernetes</span> providers.</p>
      <p>The <span class="bold">null</span> provider is a do nothing provider that can be use for executing commands, while the
        <span class="bold">kubernetes</span> provider allows as to provision resources in our <span class="bold">minikube</span>
        cluster.</p>
    </div>
    <div id="para-div">
      <p>The following is the basic definition of our <span class="bold">Terraform</span> configuration file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">main.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Configuration
#

provider "null" {
}

resource "null_resource" "create-html" {
  provisioner "local-exec" {
    command = "ssh -o \"StrictHostKeyChecking no\" -i $HOME/.minikube/machines/minikube/id_rsa docker@$(minikube ip) \"echo 'HOORAY - From Persistent Volume (local) !!!' > /pv-storage/index.html\""
  }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>The first step is to perform a <span class="bold">Terraform</span> initialization, which prepares the current users working
        directory, by downloading the specified provider(s) and caching them locally. To do that, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform init</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.12</h4>
      <pre>Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/null...
- Installing hashicorp/null v3.2.1...
- Installed hashicorp/null v3.2.1 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To list all the contents in the current working directory, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ ls -al</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.13</h4>
      <pre>total 20
drwxrwxr-x 3 alice alice 4096 Mar 11 21:16 .
drwxr-xr-x 4 alice alice 4096 Mar 11 20:38 ..
-rw-rw-r-- 1 alice alice  371 Mar 11 21:11 main.tf
drwxr-xr-x 3 alice alice 4096 Mar 11 21:16 .terraform
-rw-r--r-- 1 alice alice 1152 Mar 11 21:16 .terraform.lock.hcl</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>The second step is to perform a <span class="bold">Terraform</span> validation, which verifies the syntax and usage of the
        various constructs in the configuration file(s). To do that, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform validate</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical trimmed output:</p>
    </div>
    <div id="out-div">
      <h4>Output.14</h4>
      <pre>Success! The configuration is valid.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>The third step is to create a <span class="bold">Terraform</span> plan, which lets one preview the changes that will be made
        to the infrastructure. To do that, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform plan -out=./vers-1.tfplan</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.15</h4>
      <pre>Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # null_resource.create-html will be created
  + resource "null_resource" "create-html" {
      + id = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

-----------------------------------------------------------------------------------------------------------------------------------

Saved the plan to: ./vers-1.tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "./vers-1.tfplan"</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>The last step is to execute the <span class="bold">Terraform</span> plan, which actually makes changes to the infrastructure.
        To do that, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform apply "./vers-1.tfplan"</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.16</h4>
      <pre>null_resource.create-html: Creating...
null_resource.create-html: Provisioning with 'local-exec'...
null_resource.create-html (local-exec): Executing: ["/bin/sh" "-c" "ssh -o \"StrictHostKeyChecking no\" -i $HOME/.minikube/machines/minikube/id_rsa docker@$(minikube ip) \"echo 'HOORAY - From Persistent Volume (local) !!!' > /pv-storage/index.html\""]
null_resource.create-html: Creation complete after 0s [id=5735136570202919635]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">COOL !!!</span> - we have successfully provisioned a resource (creation of the HTML content in our
        <span class="bold">minikube</span> cluster) using <span class="bold">Terraform</span>.</p>
    </div>
    <div id="para-div">
      <p>We will now add a <span class="bold">Terraform</span> variables file and modify the <span class="bold">Terraform</span>
        configuration file to provision a persistent volume in our <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>The following is the definition of our <span class="bold">Terraform</span> variables file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">variables.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Variables
#

variable "config-path" {
  type = string
  description = "The path to the Kubernetes config directory"
  default = "~/.kube/config"
}

variable "config-context" {
  type = string
  description = "The current cointext of the Kubernetes cluster"
  default = "minikube"
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>The following is the modified definition of our <span class="bold">Terraform</span> configuration file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">main.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Configuration
#

provider "null" {
}

provider "kubernetes" {
  config_path    = var.config-path
  config_context = var.config-context
}

resource "null_resource" "create-html" {
  provisioner "local-exec" {
    command = "ssh -o \"StrictHostKeyChecking no\" -i $HOME/.minikube/machines/minikube/id_rsa docker@$(minikube ip) \"echo 'HOORAY - From Persistent Volume (local) !!!' > /pv-storage/index.html\""
  }
}

resource "kubernetes_persistent_volume" "pv-storage" {
    metadata {
      name = "pv-storage"
    }
    
    spec {
      storage_class_name = "standard"
      capacity = {
        storage = "2Gi"
      }
      access_modes = ["ReadWriteOnce"]
      persistent_volume_reclaim_policy = "Delete"
      persistent_volume_source {
        host_path {
          path = "/pv-storage"
        }
      }
    }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>To initialize <span class="bold">Terraform</span>, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform init</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.17</h4>
      <pre>Initializing the backend...

Initializing provider plugins...
- Reusing previous version of hashicorp/null from the dependency lock file
- Finding latest version of hashicorp/kubernetes...
- Installing hashicorp/kubernetes v2.18.1...
- Installed hashicorp/kubernetes v2.18.1 (signed by HashiCorp)
- Using previously-installed hashicorp/null v3.2.1

Terraform has made some changes to the provider dependency selections recorded
in the .terraform.lock.hcl file. Review those changes and commit them to your
version control system if they represent changes you intended to make.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To validate <span class="bold">Terraform</span> file(s), execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform validate</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical trimmed output:</p>
    </div>
    <div id="out-div">
      <h4>Output.18</h4>
      <pre>Success! The configuration is valid.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To create a <span class="bold">Terraform</span> execution plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform plan -out=./vers-2.tfplan</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.19</h4>
      <pre>null_resource.create-html: Refreshing state... [id=5735136570202919635]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_persistent_volume.pv-storage will be created
  + resource "kubernetes_persistent_volume" "pv-storage" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "pv-storage"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + access_modes                     = [
              + "ReadWriteOnce",
            ]
          + capacity                         = {
              + "storage" = "2Gi"
            }
          + persistent_volume_reclaim_policy = "Delete"
          + storage_class_name               = "standard"
          + volume_mode                      = "Filesystem"

          + persistent_volume_source {
              + host_path {
                  + path = "/pv-storage"
                }
            }
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

-----------------------------------------------------------------------------------------------------------------------------------

Saved the plan to: ./vers-2.tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "./vers-2.tfplan"</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice something interesting from the Output.19 above ???</p>
      <p><span class="bold">Terraform</span> indicates that there is just <span class="underbold">ONE</span> addition and no other
        changes to our <span class="bold">minikube</span> cluster, even though we left the previous <span class="bold">create-html
        </span> resource as is in the configuration file.</p>
    </div>
    <div id="para-div">
      <p>Once again, let us list the contents of the current working directory by executing the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ ls -al</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.20</h4>
      <pre>total 40
drwxrwxr-x 3 alice alice 4096 Mar 11 22:14 .
drwxr-xr-x 4 alice alice 4096 Mar 11 20:38 ..
-rw-rw-r-- 1 alice alice  822 Mar 11 22:06 main.tf
drwxr-xr-x 3 alice alice 4096 Mar 11 21:48 .terraform
-rw-r--r-- 1 alice alice 2204 Mar 11 22:07 .terraform.lock.hcl
-rw-rw-r-- 1 alice alice 2885 Mar 11 22:14 terraform.tfstate
-rw-rw-r-- 1 alice alice  578 Mar 11 22:14 terraform.tfstate.backup
-rw-rw-r-- 1 alice alice  299 Mar 11 22:05 variables.tf
-rw-rw-r-- 1 alice alice 2208 Mar 11 21:48 vers-1.tfplan
-rw-rw-r-- 1 alice alice 4067 Mar 11 22:11 vers-2.tfplan</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the presence of the file <span class="hi-blue">terraform.tfstate</span>. This is the state file created and maintained
        by <span class="bold">Terraform</span>. The state file maintains the current state of the infrastructure and what is defined
        in the configuration file. This is how <span class="bold">Terraform</span> is able to detect changes to the infrastructure.</p>
    </div>
    <div id="para-div">
      <p>To execute the <span class="bold">Terraform</span> plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform apply "./vers-2.tfplan"</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.21</h4>
      <pre>kubernetes_persistent_volume.pv-storage: Creating...
kubernetes_persistent_volume.pv-storage: Creation complete after 0s [id=pv-storage]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To display the details of the available <span class="bold">Persistent Volume</span>s in our <span class="bold">minikube</span>
        cluster, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ kubectl get pv</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.22</h4>
      <pre>NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
pv-storage   2Gi        RWO            Delete           Available           standard                21s</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">GOOD !!!</span> - we have successfully provisioned the local storage in our <span class="bold">minikube
        </span> cluster using <span class="bold">Terraform</span>.</p>
    </div>
    <div id="para-div">
      <p>Once again, we will modify the <span class="bold">Terraform</span> configuration file to provision a persistent volume claim
        which references the just created persistent volume from our <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>The following is the modified definition of our <span class="bold">Terraform</span> configuration file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">main.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Configuration
#
  
provider "null" {
}

provider "kubernetes" {
  config_path    = var.config-path
  config_context = var.config-context
}

resource "null_resource" "create-html" {
  provisioner "local-exec" {
    command = "ssh -o \"StrictHostKeyChecking no\" -i $HOME/.minikube/machines/minikube/id_rsa docker@$(minikube ip) \"echo 'HOORAY - From Persistent Volume (local) !!!' > /pv-storage/index.html\""
  }
}

resource "kubernetes_persistent_volume" "pv-storage" {
    metadata {
      name = "pv-storage"
    }
    
    spec {
      storage_class_name = "standard"
      capacity = {
        storage = "2Gi"
      }
      access_modes = ["ReadWriteOnce"]
      persistent_volume_reclaim_policy = "Delete"
      persistent_volume_source {
        host_path {
          path = "/pv-storage"
        }
      }
    }
}

resource "kubernetes_persistent_volume_claim" "pv-storage-claim" {
  metadata {
    name = "pv-storage-claim"
  }
  
  spec {
    storage_class_name = "standard"
    access_modes = ["ReadWriteOnce"]
    resources {
      requests = {
        storage = "2Gi"
      }
    }
    volume_name = "${kubernetes_persistent_volume.pv-storage.metadata[0].name}"
  }
  
  depends_on = [kubernetes_persistent_volume.pv-storage]
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Once again, to initialize <span class="bold">Terraform</span>, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform init</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.23</h4>
      <pre>Initializing the backend...

Initializing provider plugins...
- Reusing previous version of hashicorp/kubernetes from the dependency lock file
- Reusing previous version of hashicorp/null from the dependency lock file
- Using previously-installed hashicorp/kubernetes v2.18.1
- Using previously-installed hashicorp/null v3.2.1

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Once again, to validate <span class="bold">Terraform</span> file(s), execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform validate</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical trimmed output:</p>
    </div>
    <div id="out-div">
      <h4>Output.24</h4>
      <pre>Success! The configuration is valid.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Once again, to create a <span class="bold">Terraform</span> execution plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform plan -out=./vers-3.tfplan</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.25</h4>
      <pre>null_resource.create-html: Refreshing state... [id=5735136570202919635]
kubernetes_persistent_volume.pv-storage: Refreshing state... [id=pv-storage]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_persistent_volume_claim.pv-storage-claim will be created
  + resource "kubernetes_persistent_volume_claim" "pv-storage-claim" {
      + id               = (known after apply)
      + wait_until_bound = true

      + metadata {
          + generation       = (known after apply)
          + name             = "pv-storage-claim"
          + namespace        = "default"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + access_modes       = [
              + "ReadWriteOnce",
            ]
          + storage_class_name = "standard"
          + volume_name        = "pv-storage"

          + resources {
              + requests = {
                  + "storage" = "2Gi"
                }
            }
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

-----------------------------------------------------------------------------------------------------------------------------------

Saved the plan to: ./vers-3.tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "./vers-3.tfplan"</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>Once again, to execute the <span class="bold">Terraform</span> plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform apply "./vers-3.tfplan"</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.26</h4>
      <pre>kubernetes_persistent_volume_claim.pv-storage-claim: Creating...
kubernetes_persistent_volume_claim.pv-storage-claim: Creation complete after 0s [id=default/pv-storage-claim]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To display the details of the available <span class="bold">Persistent Volume Claim</span>s in our <span class="bold">minikube
        </span> cluster, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ kubectl get pvc</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.27</h4>
      <pre>NAME               STATUS   VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS   AGE
pv-storage-claim   Bound    pv-storage   2Gi        RWO            standard       44s</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">COOL !!!</span> - we have successfully deployed the storage request definition to our <span class="bold">
        minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>We will now modify both the <span class="bold">Terraform</span> variables and configuration files to deploy a webserver in
        our <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>The following is the modified definition of the <span class="bold">Terraform</span> variables file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">variables.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Variables
#

variable "config-path" {
  type = string
  description = "The path to the Kubernetes config directory"
  default = "~/.kube/config"
}

variable "config-context" {
  type = string
  description = "The current cointext of the Kubernetes cluster"
  default = "minikube"
}

variable "nginx-server" {
  type = string
  description = "The name of the nginx server that will be deployed to Kubernetes"
  default = "nginx-server"
}

variable "nginx-storage" {
  type = string
  description = "The name of the storage volume used by the nginx server in Kubernetes"
  default = "nginx-storage"
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>The following is the modified definition of the <span class="bold">Terraform</span> configuration file:</p>
    </div>
    <br/>
    <div id="gen-src-outer-div">
      <div class="gen-src-cap">main.tf</div>
      <div class="gen-src-body">
<pre>#
### Terraform Configuration
#

provider "null" {
}

provider "kubernetes" {
  config_path    = var.config-path
  config_context = var.config-context
}

resource "null_resource" "create-html" {
  provisioner "local-exec" {
    command = "ssh -o \"StrictHostKeyChecking no\" -i $HOME/.minikube/machines/minikube/id_rsa docker@$(minikube ip) \"echo 'HOORAY - From Persistent Volume (local) !!!' > /pv-storage/index.html\""
  }
}

resource "kubernetes_persistent_volume" "pv-storage" {
    metadata {
      name = "pv-storage"
    }
    
    spec {
      storage_class_name = "standard"
      capacity = {
        storage = "2Gi"
      }
      access_modes = ["ReadWriteOnce"]
      persistent_volume_reclaim_policy = "Delete"
      persistent_volume_source {
        host_path {
          path = "/pv-storage"
        }
      }
    }
}

resource "kubernetes_persistent_volume_claim" "pv-storage-claim" {
  metadata {
    name = "pv-storage-claim"
  }
  
  spec {
    storage_class_name = "standard"
    access_modes = ["ReadWriteOnce"]
    resources {
      requests = {
        storage = "2Gi"
      }
    }
    volume_name = "${kubernetes_persistent_volume.pv-storage.metadata[0].name}"
  }
  
  depends_on = [kubernetes_persistent_volume.pv-storage]
}

resource "kubernetes_deployment" "nginx-deploy" {
 metadata {
   name = "nginx-deploy"
   labels = {
     app = var.nginx-server
   }
 }

 spec {
   replicas = 1
   
   selector {
     match_labels = {
       app = var.nginx-server
     }
   }

   template {
     metadata {
       labels = {
         app = var.nginx-server
       }
     }

     spec {
       container {
         name  = var.nginx-server
         image = "nginx:1.23.3"
         
         port {
           name = var.nginx-server
           container_port = 80
         }
         
         volume_mount {
           name = var.nginx-storage
           mount_path = "/usr/share/nginx/html"
         }
       }
       
       volume {
         name = var.nginx-storage
         
         persistent_volume_claim {
           claim_name = "pv-storage-claim"
         }
       }
     }
   }
 }
  
 depends_on = [kubernetes_persistent_volume_claim.pv-storage-claim]
}

output "nginx-deploy" {
 value = "${kubernetes_deployment.nginx-deploy.metadata[0].name} deployed successfully !!!"
 
 depends_on = [kubernetes_deployment.nginx-deploy]
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>One last time, to initialize <span class="bold">Terraform</span>, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform init</p>
    </div>
    <div id="para-div">
      <p>The response will be similar to that of the Output.23 from above.</p>
    </div>
    <div id="para-div">
      <p>One last time, to validate <span class="bold">Terraform</span> file(s), execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform validate</p>
    </div>
    <div id="para-div">
      <p>The response will be similar to that of the Output.24 from above.</p>
    </div>
    <div id="para-div">
      <p>One last time, to create a <span class="bold">Terraform</span> execution plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform plan -out=./vers-4.tfplan</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.28</h4>
      <pre>null_resource.create-html: Refreshing state... [id=5735136570202919635]
kubernetes_persistent_volume.pv-storage: Refreshing state... [id=pv-storage]
kubernetes_persistent_volume_claim.pv-storage-claim: Refreshing state... [id=default/pv-storage-claim]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_deployment.nginx-deploy will be created
  + resource "kubernetes_deployment" "nginx-deploy" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "nginx-server"
            }
          + name             = "nginx-deploy"
          + namespace        = "default"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = "1"
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "nginx-server"
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "nginx-server"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }
              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "nginx:1.23.3"
                      + image_pull_policy          = (known after apply)
                      + name                       = "nginx-server"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 80
                          + name           = "nginx-server"
                          + protocol       = "TCP"
                        }

                      + volume_mount {
                          + mount_path        = "/usr/share/nginx/html"
                          + mount_propagation = "None"
                          + name              = "nginx-storage"
                          + read_only         = false
                        }
                    }

                  + volume {
                      + name = "nginx-storage"

                      + persistent_volume_claim {
                          + claim_name = "pv-storage-claim"
                          + read_only  = false
                        }
                    }
                }
            }
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + nginx-deploy = "nginx-deploy deployed successfully !!!"

-----------------------------------------------------------------------------------------------------------------------------------

Saved the plan to: ./vers-4.tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "./vers-4.tfplan"</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To finally execute the <span class="bold">Terraform</span> plan, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform apply "./vers-4.tfplan"</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.29</h4>
      <pre>kubernetes_deployment.nginx-deploy: Creating...
kubernetes_deployment.nginx-deploy: Creation complete after 8s [id=default/nginx-deploy]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

Outputs:

nginx-deploy = "nginx-deploy deployed successfully !!!"</pre>
    </div>
    <br/>
    <div id="para-div">
      <p>To display the details of the underlying application pod(s), execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ kubectl get po</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.30</h4>
      <pre>NAME                           READY   STATUS    RESTARTS   AGE
nginx-deploy-65f5df4858-8fkr2  1/1     Running   0          16s</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">GREAT !!!</span> - we have successfully deployed the webserver application to our <span class="bold">
        minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>Now is the time to test if our webserver container is able to serve the <span class="bold">index.html</span> file from the
        local storage volume attached to the <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>To access the webserver from the deployed pod, execute the following commands:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ kubectl exec -it nginx-deploy-65f5df4858-8fkr2 -- /bin/bash</p>
      <p>root@nginx-deploy-65f5df4858-8fkr2:/# curl http://localhost</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.31</h4>
      <pre>HOORAY - From Persistent Volume (local) !!!</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">WALLA !!!</span> - we have successfully tested the access to the local storage volume attached to our
        <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>To exit from the webserver pod, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>root@nginx-deploy-65f5df4858-8fkr2:/# exit</p>
    </div>
    <div id="para-div">
      <p>It is time to perform clean-up by deleting all the deployed resources from our <span class="bold">minikube</span> cluster.</p>
    </div>
    <div id="para-div">
      <p>To delete the webserver deployment, execute the following command:</p>
    </div>
    <div id="gen-cmd-div">
      <p>$ terraform destroy -auto-approve</p>
    </div>
    <div id="para-div">
      <p>The following would be a typical output:</p>
    </div>
    <div id="out-div">
      <h4>Output.32</h4>
      <pre>null_resource.create-html: Refreshing state... [id=5735136570202919635]
kubernetes_persistent_volume.pv-storage: Refreshing state... [id=pv-storage]
kubernetes_persistent_volume_claim.pv-storage-claim: Refreshing state... [id=default/pv-storage-claim]
kubernetes_deployment.nginx-deploy: Refreshing state... [id=default/nginx-deploy]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following
symbols:
  - destroy

Terraform will perform the following actions:

  # kubernetes_deployment.nginx-deploy will be destroyed
  - resource "kubernetes_deployment" "nginx-deploy" {
      - id               = "default/nginx-deploy" -> null
      - wait_for_rollout = true -> null

      - metadata {
          - annotations      = {} -> null
          - generation       = 1 -> null
          - labels           = {
              - "app" = "nginx-server"
            } -> null
          - name             = "nginx-deploy" -> null
          - namespace        = "default" -> null
          - resource_version = "33772" -> null
          - uid              = "1749244f-38d3-407c-b9b4-259032454785" -> null
        }

      - spec {
          - min_ready_seconds         = 0 -> null
          - paused                    = false -> null
          - progress_deadline_seconds = 600 -> null
          - replicas                  = "1" -> null
          - revision_history_limit    = 10 -> null

          - selector {
              - match_labels = {
                  - "app" = "nginx-server"
                } -> null
            }

          - strategy {
              - type = "RollingUpdate" -> null

              - rolling_update {
                  - max_surge       = "25%" -> null
                  - max_unavailable = "25%" -> null
                }
            }

          - template {
              - metadata {
                  - annotations = {} -> null
                  - generation  = 0 -> null
                  - labels      = {
                      - "app" = "nginx-server"
                    } -> null
                }
              - spec {
                  - active_deadline_seconds          = 0 -> null
                  - automount_service_account_token  = true -> null
                  - dns_policy                       = "ClusterFirst" -> null
                  - enable_service_links             = true -> null
                  - host_ipc                         = false -> null
                  - host_network                     = false -> null
                  - host_pid                         = false -> null
                  - node_selector                    = {} -> null
                  - restart_policy                   = "Always" -> null
                  - share_process_namespace          = false -> null
                  - termination_grace_period_seconds = 30 -> null

                  - container {
                      - args                       = [] -> null
                      - command                    = [] -> null
                      - image                      = "nginx:1.23.3" -> null
                      - image_pull_policy          = "IfNotPresent" -> null
                      - name                       = "nginx-server" -> null
                      - stdin                      = false -> null
                      - stdin_once                 = false -> null
                      - termination_message_path   = "/dev/termination-log" -> null
                      - termination_message_policy = "File" -> null
                      - tty                        = false -> null

                      - port {
                          - container_port = 80 -> null
                          - host_port      = 0 -> null
                          - name           = "nginx-server" -> null
                          - protocol       = "TCP" -> null
                        }

                      - resources {
                          - limits   = {} -> null
                          - requests = {} -> null
                        }

                      - volume_mount {
                          - mount_path        = "/usr/share/nginx/html" -> null
                          - mount_propagation = "None" -> null
                          - name              = "nginx-storage" -> null
                          - read_only         = false -> null
                        }
                    }

                  - volume {
                      - name = "nginx-storage" -> null

                      - persistent_volume_claim {
                          - claim_name = "pv-storage-claim" -> null
                          - read_only  = false -> null
                        }
                    }
                }
            }
        }
    }

  # kubernetes_persistent_volume.pv-storage will be destroyed
  - resource "kubernetes_persistent_volume" "pv-storage" {
      - id = "pv-storage" -> null

      - metadata {
          - annotations      = {} -> null
          - generation       = 0 -> null
          - labels           = {} -> null
          - name             = "pv-storage" -> null
          - resource_version = "24590" -> null
          - uid              = "cd536e4d-d453-463e-a260-6854de327ddf" -> null
        }

      - spec {
          - access_modes                     = [
              - "ReadWriteOnce",
            ] -> null
          - capacity                         = {
              - "storage" = "2Gi"
            } -> null
          - mount_options                    = [] -> null
          - persistent_volume_reclaim_policy = "Delete" -> null
          - storage_class_name               = "standard" -> null
          - volume_mode                      = "Filesystem" -> null

          - claim_ref {
              - name      = "pv-storage-claim" -> null
              - namespace = "default" -> null
            }

          - persistent_volume_source {
              - host_path {
                  - path = "/pv-storage" -> null
                }
            }
        }
    }

  # kubernetes_persistent_volume_claim.pv-storage-claim will be destroyed
  - resource "kubernetes_persistent_volume_claim" "pv-storage-claim" {
      - id               = "default/pv-storage-claim" -> null
      - wait_until_bound = true -> null

      - metadata {
          - annotations      = {} -> null
          - generation       = 0 -> null
          - labels           = {} -> null
          - name             = "pv-storage-claim" -> null
          - namespace        = "default" -> null
          - resource_version = "24592" -> null
          - uid              = "39be4394-25b0-42c0-8169-315d41d8010a" -> null
        }

      - spec {
          - access_modes       = [
              - "ReadWriteOnce",
            ] -> null
          - storage_class_name = "standard" -> null
          - volume_name        = "pv-storage" -> null

          - resources {
              - limits   = {} -> null
              - requests = {
                  - "storage" = "2Gi"
                } -> null
            }
        }
    }

  # null_resource.create-html will be destroyed
  - resource "null_resource" "create-html" {
      - id = "5735136570202919635" -> null
    }

Plan: 0 to add, 0 to change, 4 to destroy.

Changes to Outputs:
  - nginx-deploy = "nginx-deploy deployed successfully !!!" -> null
null_resource.create-html: Destroying... [id=5735136570202919635]
null_resource.create-html: Destruction complete after 0s
kubernetes_deployment.nginx-deploy: Destroying... [id=default/nginx-deploy]
kubernetes_deployment.nginx-deploy: Destruction complete after 0s
kubernetes_persistent_volume_claim.pv-storage-claim: Destroying... [id=default/pv-storage-claim]
kubernetes_persistent_volume_claim.pv-storage-claim: Destruction complete after 2s
kubernetes_persistent_volume.pv-storage: Destroying... [id=pv-storage]
kubernetes_persistent_volume.pv-storage: Destruction complete after 0s

Destroy complete! Resources: 4 destroyed.</pre>
    </div>
    <br/>
    <div id="para-div">
      <p><span class="bold">BINGO !!!</span> - we have successfully demonstrated the use of <span class="bold">Terraform</span>
        as a infrastructure management tool on our <span class="bold">minikube</span> cluster.</p>
    </div>
    <br/>
    <div id="gen-step-div">
      <p>References</p>
    </div>
    <br/>
    <div id="para-div">
      <p><a href="https://registry.terraform.io/" target="_blank"><span class="bold">Terraform Registry</span></a></p>
    </div>
    <br/>
    <hr class="gen-line-hr" />
    <div>
      <a id="gen-footer-a" href="https://polarsparc.github.io/">&copy;&nbsp;PolarSPARC</a>
    </div>
  </body>
</html>
