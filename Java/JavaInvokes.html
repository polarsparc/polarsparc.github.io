<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="application/xhtml+xml; charset=windows-1252" />
    <meta name="author" content="Bhaskar.S">
    <meta name="description" content="The JVM 'Invoke...' Instructions">
    <meta name="subject" content="The JVM 'Invoke...' Instructions">
    <meta name="keywords" content="java, jvm">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <title>The JVM 'Invoke...' Instructions</title>
    <link href="../css/polarsparc-v2.4.css" type="text/css" rel="stylesheet" />
  </head>
  <body>
    <br/>
    <table borber="0">
      <tr>
        <td valign="bottom"><span id="ps-home"></span></td>
        <td valign="bottom"><span id="home-a"><a id="home-a" href="https://polarsparc.github.io/">PolarSPARC</a></span></td>
      </tr>
    </table>
    <br/>
    <div id="title-div">
      <p>The JVM 'Invoke...' Instructions</p>
    </div>
    <br />
    <table id="ad-table">
      <tbody>
        <tr>
          <td class="author-td">Bhaskar S</td>
          <td class="date-td">08/31/2024</td>
        </tr>
      </tbody>
    </table>
    <hr class="line-hr" />
    <br/>
    <div id="para-div">
      <p>If one decompiled a <span class="bold">Java</span> class and looked under-the-hood, one would notice that the <span class=
        "bold">Java Virtual Machine</span> (or <span class="bold">JVM</span> for short) uses <span class="underbold">FIVE</span>
        different types of method invocation instructions.</p>
      <p>In this article, we will explore the situations in which the 5 different JVM method invocation instructions are used via
        simple code examples.</p>
    </div>
    <div id="para-div">
      <p>Before we get started, we will cover two aspects - a concept and an utility.</p>
      <p>First, let us understand the concept of a <span class="hi-yellow">Constant Pool</span>. It is an in-memory, runtime data
        structure representation of a <span class="bold">Java</span> class file, which behaves like a key-value lookup table that
        contains references to symbols generated by compiler. In other words, it contains references to the names of classes used,
        initial values of strings and numeric constants, methods and their parameters, and other miscellaneous information that are
        important for the proper execution of the <span class="bold">Java</span> class.</p>
      <p>Next, to disessemble a <span class="bold">Java</span> class and reveal the bytecode instructions, one would use the <span
        class="hi-yellow">javap</span> utility as follows:</p>
    </div>
    <br/>
    <div id="cmd-div">
      <p>$ javap -c -v &lt;full-path-to-the-class&gt;</p>
    </div>
    <br/>
    <div id="para-div">
      <p>where the option <span class="bold">-c</span> implies disassemble.</p>
    </div>
    <div id="para-div">
      <p>With that out off the way, let us now proceed to explore and understand each of the JVM invocation instructions.</p>
    </div>
    <table id="step-table">
      <tbody>
      <tr>
        <td class="text-td">invokestatic</td>
        <td class="pointer-td"></td>
      </tr>
      </tbody>
    </table>
    <div id="para-div">
      <p>Given a <span class="bold">Java</span> class with <span class="bold">static</span> method(s), they belong to the specific
        class and can be invoked directly on the class. Hence, they are often referred to as class method(s).</p>
      <p>The <span class="hi-purple">invokestatic</span> JVM instruction is used to invoke class method(s) and does not require an
        class instance reference on which to invoke the specific method. This JVM instruction references an index location in the
        <span class="bold">Constant Pool</span>, which in turn points to the specific method descriptor (fully qualified method name,
        parameters, and return type) to be called.</p>
    </div>
    <div id="para-div">
      <p>Let us consider the following simple <span class="bold">Java</span> class:</p>
    </div>
    <br/>
    <div id="src-outer-div-1">
      <div class="src-cap-1">Sample_1.java</div>
      <div class="src-body-1">
        <pre>/*
 * Name:   Sample_1
 * Author: Bhaskar S
 * Date:   08/25/2024
 * Blog:   https://polarsparc.github.io
 */

package com.polarsparc.calls;

public class Sample_1 {
    public static void main(String[] args) {
        Sample_1.call();
    }

    public static void call() {}
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Disassembling the above <span class="bold">Java</span> class results in the following trimmed bytecode:</p>
    </div>
    <br/>
    <div id="img-outer-div"> <img src="./images/jvm_invokes-1.png" class="img-cls" alt="Invoke Static" />
      <div class="img-cap">Sample_1 Bytecode</div>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the <span class="bold">invokestatic</span> instruction is referring to index <span class="bold">#7</span> in the
        <span class="bold">Constant Pool</span> which is the method reference for the specific method call.</p>
    </div>
    <table id="step-table">
      <tbody>
      <tr>
        <td class="text-td">invokespecial</td>
        <td class="pointer-td"></td>
      </tr>
      </tbody>
    </table>
    <div id="para-div">
      <p>The <span class="hi-purple">invokespecial</span> JVM instruction is used to execute a method based on the type of the object
        reference rather than the class object. This JVM instruction comes into play in three scenarios, which are as follows:</p>
      <ul id="blue-sqr-ul">
        <li>
          <p>Class instance initialization</p>
        </li>
        <li>
          <p>Explicit calls to parent methods using the <span class="bold">super</span> keyword</p>
        </li>
        <li>
          <p>Invoking <span class="bold">private</span> methods</p>
        </li>
      </ul>
    </div>
    <div id="para-div">
      <p>Let us consider the following simple <span class="bold">Java</span> class:</p>
    </div>
    <br/>
    <div id="src-outer-div-1">
      <div class="src-cap-1">Sample_2.java</div>
      <div class="src-body-1">
        <pre>/*
 * Name:   Sample_2
 * Author: Bhaskar S
 * Date:   08/25/2024
 * Blog:   https://polarsparc.github.io
 */

package com.polarsparc.calls;

public class Sample_2 {
    public static void main(String[] args) {
        new C1();
    }

    static class C1 {
    }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Disassembling the above <span class="bold">Java</span> class results in the following trimmed bytecode:</p>
    </div>
    <br/>
    <div id="img-outer-div"> <img src="./images/jvm_invokes-2.png" class="img-cls" alt="Invoke Special" />
      <div class="img-cap">Sample_2 Bytecode</div>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the <span class="bold">invokestatic</span> instruction is referring to index <span class="bold">#7</span> in the
        <span class="bold">Constant Pool</span> which is the method reference for the specific method call.</p>
    </div>
    <table id="step-table">
      <tbody>
      <tr>
        <td class="text-td">invokevirtual</td>
        <td class="pointer-td"></td>
      </tr>
      </tbody>
    </table>
    <div id="para-div">
      <p>The <span class="hi-purple">invokevirtual</span> is the default JVM instruction to dynamically invoke a non-static, class
        instance method (based on the exact name and type) on an object reference. The specified method is invoked on the specific
        object reference at the top of the operand stack, at runtime, thus allowing support for the <span class="bold">polymorphic
        </span> behavior.</p>
    </div>
    <div id="para-div">
      <p>Let us consider the following simple <span class="bold">Java</span> class:</p>
    </div>
    <br/>
    <div id="src-outer-div-1">
      <div class="src-cap-1">Sample_3.java</div>
      <div class="src-body-1">
        <pre>/*
 * Name:   Sample_3
 * Author: Bhaskar S
 * Date:   08/25/2024
 * Blog:   https://polarsparc.github.io
 */

package com.polarsparc.calls;

public class Sample_3 {
    public static void main(String[] args) {
        C1 c1 = new C2();
        c1.call();
    }

    static class C1 {
        void call() {}
    }

    static class C2 extends C1 {
        @Override
        void call() {}
    }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Disassembling the above <span class="bold">Java</span> class results in the following trimmed bytecode:</p>
    </div>
    <br/>
    <div id="img-outer-div"> <img src="./images/jvm_invokes-3.png" class="img-cls" alt="Invoke Virtual" />
      <div class="img-cap">Sample_3 Bytecode</div>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the <span class="bold">invokespecial</span> instruction is referring to index <span class="bold">#9</span> in the
        <span class="bold">Constant Pool</span> which is constructor call for the class <span class="bold">C2</span>, which is the
        <span class="bold">this</span> object reference at the top of the stack frame.</p>
    </div>
    <table id="step-table">
      <tbody>
      <tr>
        <td class="text-td">invokeinterface</td>
        <td class="pointer-td"></td>
      </tr>
      </tbody>
    </table>
    <div id="para-div">
      <p>The <span class="hi-purple">invokeinterface</span> is similar to the <span class="bold">invokevirtual</span> JVM instruction
        except that it is used when the object reference is an <span class="bold">interface</span> type.</p>
    </div>
    <div id="para-div">
      <p>Let us consider the following simple <span class="bold">Java</span> class:</p>
    </div>
    <br/>
    <div id="src-outer-div-1">
      <div class="src-cap-1">Sample_4.java</div>
      <div class="src-body-1">
        <pre>/*
 * Name:   Sample_4
 * Author: Bhaskar S
 * Date:   08/25/2024
 * Blog:   https://polarsparc.github.io
 */

package com.polarsparc.calls;

public class Sample_4 {
    public static void main(String[] args) {
        C1 c1 = new C2();
        c1.call();
    }

    static interface C1 {
        public void call();
    }

    static class C2 implements C1 {
        @Override
        public void call() {}
    }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Disassembling the above <span class="bold">Java</span> class results in the following trimmed bytecode:</p>
    </div>
    <br/>
    <div id="img-outer-div"> <img src="./images/jvm_invokes-4.png" class="img-cls" alt="Invoke Interface" />
      <div class="img-cap">Sample_4 Bytecode</div>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the <span class="bold">invokeinterface</span> instruction is referring to index <span class="bold">#10</span> in the
        <span class="bold">Constant Pool</span> which is a method reference to an <span class="bold">interface</span> type.</p>
    </div>
    <table id="step-table">
      <tbody>
      <tr>
        <td class="text-td">invokedynamic</td>
        <td class="pointer-td"></td>
      </tr>
      </tbody>
    </table>
    <div id="para-div">
      <p>Before we proceed further, we need to review the following three concepts:</p>
      <ul id="blue-sqr-ul">
        <li>
          <p>Call Site</p>
        </li>
        <li>
          <p>Method Handle</p>
        </li>
        <li>
          <p>Bootstrap Method</p>
        </li>
      </ul>
      <p>A <span class="hi-yellow">Call Site</span> (implemented as the class <span class="bold">java.lang.invoke.CallSite</span>)
        is the location in the bytecode where a method invocation instruction occurs.</p>
      <p>A <span class="hi-yellow">Method Handle</span> (implemented as the class <span class="bold">java.lang.invoke.MethodHandle</span>)
        is the <span class="bold">Java</span> language equivalent of a function pointer that is type-safe.</p>
      <p>A <span class="hi-yellow">Bootstrap Method</span> is a special method that helps resolve the target method to be called at
        runtime. It returns a reference to a <span class="bold">CallSite</span> with the correct target method binding.</p>
    </div>
    <div id="para-div">
      <p>The <span class="hi-purple">invokedynamic</span> JVM instruction is used for supporting dynamic languages (such as <span
        class="bold">Groovy</span>, <span class="bold">JPython</span>, etc) where the method binding happens much later at runtime
        (duck typing), thus allowing the JVM to optimize the dynamic method invocation.</p>
      <p>When the JVM encounters this instruction, it uses the operands to lookup the target <span class="bold">CallSite</span>. If
        the <span class="bold">CallSite</span> is not linked to any method, the JVM invokes the <span class="bold">Bootstrap</span>
        method to resolve the method binding. Once resolved, the <span class="bold">CallSite</span> points to a valid <span class=
        "bold">MethodHandle</span> which allows the JVM to invoke the appropriate target method.</p>
    </div>
    <div id="para-div">
      <p>Let us consider the following simple <span class="bold">Java</span> class:</p>
    </div>
    <br/>
    <div id="src-outer-div-1">
      <div class="src-cap-1">Sample_5.java</div>
      <div class="src-body-1">
        <pre>/*
 * Name:   Sample_5
 * Author: Bhaskar S
 * Date:   08/25/2024
 * Blog:   https://polarsparc.github.io
 */

package com.polarsparc.calls;

public class Sample_5 {
    public static void main(String[] args) {
        Runnable r = () -> {};
        r.run();
    }
}</pre>
      </div>
    </div>
    <br/>
    <div id="para-div">
      <p>Disassembling the above <span class="bold">Java</span> class results in the following trimmed bytecode:</p>
    </div>
    <br/>
    <div id="img-outer-div"> <img src="./images/jvm_invokes-5.png" class="img-cls" alt="Invoke Dynamic" />
      <div class="img-cap">Sample_5 Bytecode</div>
    </div>
    <br/>
    <div id="para-div">
      <p>Notice the <span class="bold">invokedynamic</span> instruction in the <span class="bold">Constant Pool</span> is referring
        to index <span class="hi-green">#0</span> of the <span class="bold">BootstrapMethods</span> section, which in turn resolves
        to a <span class="bold">lambda</span> target in the <span class="bold">Constant Pool</span> at index <span class="hi-blue">
        #36</span>.</p>
    </div>
    <br/>
    <div id="section-div">
      <p>References</p>
    </div>
    <div id="para-div">
      <p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank"><span class="bold">Java Virtual Machine Instructions</span></a></p>
    </div>
    <hr class="line-hr" />
    <div>
      <a id="footer-a" href="https://polarsparc.github.io/">&copy;&nbsp;PolarSPARC</a>
    </div>
  </body>
</html>
